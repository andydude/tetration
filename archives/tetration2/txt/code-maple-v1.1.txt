## Usage:#### prep := superlog_prepare(x, n):  -- Prepares for slog_x(z)_n## superlog(x, z);                  -- Prepares fast (n=10)## superlog(prep, z);               -- Uses 'prep'## superlog(z);                     -- Uses 'Global_superlog_prep'##with(linalg):superlog_prepare := proc(x, n::integer)    [x, linsolve(matrix([seq([seq(        k^j/k!-`if`(j=k,1,0)*log(x)^(-j),         k=1..n)], j=0..(n - 1))]),        [seq(`if`(k=1,1,0),k=1..n)])];end proc;superlog_linear := proc(x, z)    superlog([x, []], z, (proc(v, z) z - 1; end proc));end proc;superlog_critical := proc(v, z)    -1 + sum(v[2][k]*z^k/k!, k=1..vectdim(v[2])); end proc;superlog := proc() local prep, x, z, f;    if (nops([args]) = 1) then        if not ([args][1]::numeric) then return 'procname'(args); end if;        superlog(Global_superlog_prep, args, superlog_critical);    elif (nops([args]) = 2) then        z := evalf([args][2]);        if not (z::numeric) then return 'procname'(args); end if;        if not ([args][1]::list) then            x := evalf([args][1]);            prep := [x, linsolve(matrix([seq([seq(                evalf(k^j/k!-`if`(j=k,1,0)*log(x)^(-j)),                 k=1..10)], j=0..9)]),                [seq(`if`(k=1,1,0),k=1..10)])];            superlog(prep, z, superlog_critical);        elif ([args][1]::list) then            superlog(args, superlog_critical);        else return 'procname'(args);        end if;    elif (nops([args]) = 3) then        z := [args][2];        f := [args][3];        if not (evalf(z)::numeric) then return 'procname'(args); end if;        if (([args][1])::list) then            prep := [args][1];            x := [args][1][1];            if not (evalf(x)::numeric) then return 'procname'(args); end if;        else return 'procname'(args); end if;        piecewise(            z < 0,              f(prep, x^z) - 1,             z = 0,              -1,            0 < z and z < 1,    f(prep, z),             z = 1,              0,            z > 1,              (proc()                    local a, i; a := evalf(z);                    for i from 0 while (a > 1) do                         a := evalf(log[x](a));                    end do; f(prep, a) + i;                 end proc)())    else return 'procname'(args);    end if;end proc;## Usage:#### prep := superlog_prepare(x, n):  -- Prepares for slog_x(z)_n## tetrate(x, y);                   -- Prepares fast (n=10)## tetrate(prep, y);                -- Uses 'prep'## tetrate(y);                      -- Uses 'Global_superlog_prep'##tetrate_critical := proc(v, y) local slog_critical;    select((proc(a) evalb(Im(a) = 0 and 0 <= Re(a) and Re(a) <= 1)         end proc), [solve(evalf(superlog_critical(v, z)) = y, z)])[1];end proc;tetrate := proc() local prep, x, y, f;    if (nops([args]) = 1) then        if not ([args][1]::numeric) then return 'procname'(args); end if;        tetrate(Global_superlog_prep, args, tetrate_critical);    elif (nops([args]) = 2) then        y := evalf([args][2]);        if not (y::numeric) then return 'procname'(args); end if;        if not ([args][1]::list) then            x := evalf([args][1]);            prep := [x, linsolve(matrix([seq([seq(                evalf(k^j/k!-`if`(j=k,1,0)*log(x)^(-j)),                 k=1..10)], j=0..9)]),                [seq(`if`(k=1,1,0),k=1..10)])];            tetrate(prep, y, tetrate_critical);        elif ([args][1]::list) then            tetrate(args, tetrate_critical);        else return 'procname'(args);        end if;    elif (nops([args]) = 3) then        y := [args][2];        f := [args][3];        if not (evalf(y)::numeric) then return 'procname'(args); end if;        if (([args][1])::list) then            prep := [args][1];            x := [args][1][1];            if not (evalf(x)::numeric) then return 'procname'(args); end if;        else return 'procname'(args); end if;        piecewise(            y = -2,             -infinity,            -2 < y and y < -1,  log[x](tetrate_critical(prep, y + 1)),            y = -1,             0,             -1 < y and y < 0,   tetrate_critical(prep, y),            y = 0,              1,             y = 1,              x,            y > 0,              (proc ()                     local a, i; a := tetrate_critical(prep, y - ceil(y));                    for i from 1 to ceil(y) do a := x^a; end do;                    evalf(a);                end proc)());    else return 'procname'(args);    end if;end proc;Global_superlog_prep := superlog_prepare(exp(1), 10):
